# Rust 所有权

> 如果一个特性不太利于程序的健壮性，但是很好用，滥用的成本非常低，那么它一定会被滥用

## 栈与堆

* Rust 中的非固定尺寸类型就是靠指针或引用来指向，而指针或引用本身就是一种固定尺寸的类型
* 栈上的操作比堆高效，因为栈上内存的分配和回收只需移动栈顶指针就行了。这就决定了分配和回收时都必须精确计算这个指针的增减量，因此栈上一般放固定尺寸的值
* 那么非固定尺寸的值怎么处理呢？在计算机体系架构里面，专门在内存中拿出一大块区域来存放这类值，这个区域就叫“堆”
* 栈帧是一个运行时的事物。函数中的参数、局部变量之类的资源，都会放在这个帧里面
* 栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。

## 所有权

1. Rust 中，每一个值都有一个所有者。
2. 任何一个时刻，一个值只有一个所有者。
3. 当所有者所在作用域（scope）结束的时候，其管理的值会被一起释放掉

* 所谓所有者，在代码里就用变量表示。而变量的作用域，就是变量有效（valid）的那个代码区间
* 栈帧中的局部变量离开作用域了，顺带要求堆内存中的字符串资源被回收
* 这种堆内存资源随着关联的栈上局部变量一起被回收的内存管理特性，叫作 RAII（Resource Acquisition Is Initialization）
* 固定尺寸变量复制所有权，可变尺寸变量移动所有权

## 引用

* 在 Rust 中，变量前用“&”符号来表示引用，比如 &x
* 引用也是一种值，并且是固定尺寸的值
* 引用分成不可变引用和可变引用
* &x 是对变量 x 的不可变引用
* &mut x 是对变量 x 的可变引用

> rules

* 一个所有权型变量的作用域是从它定义时开始到花括号结束
* 引用型变量的作用域是从它定义起到它最后一次使用时结束
* 一个所有权型变量的不可变引用可以同时存在多个，可以复制多份
* 一个所有权型变量的可变引用与不可变引用的作用域不能交叠，也可以说不能同时存在
* 同一个所有权型变量的可变借用之间的作用域也不能交叠
* 在有借用存在的情况下，不能通过原所有权型变量对值进行更新
* 一个所有权型变量的可变引用也具有所有权特征
* 在任意给定时间，**要么** 只能有一个可变引用，**要么** 只能有多个不可变引用

## 思考

* 数据无外乎已知大小和未知大小
* 已知大小的编译时即可确定需要占用多少空间，放在栈上，用完即销毁
* 未知大小的需要申请空间放在堆上，再由指针放在栈上使用
* 但是堆上的空间使用后谁来处理呢？和栈上的指针绑定上
* 但是这个指针能来回传，大家都随便用么，显然就乱套了，它必须有个唯一的负责人
* 由此引出了所有权的概念，赋值出去了，所有权也就交出去了，函数调用传参也是同理
* 然后按下葫芦浮起瓢，所有权交出去了，还想用就得在拿回来
* 相当于函数的入参也得当返回值返回给调用者，就挺诡异和啰嗦的
* 怎么办？传引用，所有权借出去，好了松了一口气
* 但是我拿了引用不但想读还想写，怎么办？加个 mut 就可以了
* 但是为了避免读写冲突，防止多个写冲突了，或者一边读一遍写冲突了
* 可变引用与不可变引用不能同时存在，同一时刻可变引用也只能有一个

## 数据竞争

> data race 类似于竞态条件，它由这三个行为造成：

* 两个或更多指针同时访问同一数据。
* 至少有一个指针被用来写入数据。
* 没有同步数据访问的机制。

以上三个行为同时发生才会造成数据竞争，而不是单一行为。